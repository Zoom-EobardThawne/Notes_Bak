# 01.C 高级

## 1、shell脚本能做哪些事情？分别举例

- 避免开发人员反复进行一些列重复步骤

  > 联网+检查安装包+安装软件+执行命令，如果经常需要做类似的操作，可以考虑将操作写成脚本

- 提高编译效率

  > 利用编写好 Makefile 文件（shell 脚本），只需要一个 make 命令，整个工程就开始自动编译

- 不依赖 IDE 就可以实现功能编码

- 方便调用机器下的所有资源



## 2、编写一个 Makefile 文件辅助编译工程

```makefile
CROSS_COMPILE = arm-none-eabi-
CC  = $(CROSS_COMPILE)gcc
LD  = $(CROSS_COMPILE)ld
OBJCOPY = $(CROSS_COMPILE)objcopy
APP = fs4412.elf
BIN = fs4412.bin
CINCLUDES = -I ./include

LDFLAGS+= -static -L ./lib -lc -lm -lnosys
LDFLAGS+= -static -L ./lib -lgcc

include config.mk

$(APP):start/start.o main.o  $(COBJS)
	$(LD) -Ttext=0x40000000 $^ -o $@ $(LDFLAGS)
	$(OBJCOPY) -O binary $(APP) $(BIN)
		
%.o:%.S
	$(CC) -c $< -o $@

%.o:%.c
	$(CC) -c $< -o $@  $(CINCLUDES)

.PHONY:clean
clean:
	-rm ./main.o $(BIN) $(APP) ./start/start.o
	-rm ./$(COBJS)
```



## 3、Linux下常用的指令有哪些？

### 3.1 文件管理

```bash
ls --- 显示指定工作目录下的文件以及属性信息
cp --- 复制文件或目录
mkdir --- 创建目录
mv --- 移动或改名文件
pwd --- 显示当前工作目录或路径
```

### 3.2 文档编辑

```bash
cat --- 在终端显示文件内容
echo --- 输出字符串或提取后的变量值
rm --- 删除文件或目录
grep --- 文本搜索
```

### 3.3 系统管理

```bash
find --- 根据路径和条件搜索指定文件
ps --- 显示进程状态
uname --- 显示系统内核信息
```

### 3.4 文件传输

```bash
tftp --- 上传及下载文件
```

### 3.5 网络

```bash
ping --- 测试主机间网络连通性
ssh --- 安全的远程连接服务器
netstat --- 显示网络状态
ifconfig --- 显示或设置网络设备参数
```





## 4、ls -l 指令查看的文件信息有哪些?

### 4.1 文件类型和权限

```bash
# 信息含义:文件类型和权限
# 该信息是由一个长度为10的字符串所表示的
# 例如:
-rw-rw-r--或drwxr-xr-x

# 字符串含义:
第一个字符含义:表示文件类型
紧接着三个字符:表示拥有者权限
紧接着三个字符:表示所属用户组权限
最后的三个字符:表示其他用户权限

# 第一个字符参数种类及含义:
'd'		表示该文件类型为:目录
'l'		表示该文件类型为:软链接
'b'		表示该文件类型为:快设备
'c'		表示该文件类型为:字符设备
's'		表示该文件类型为:socket
'p'		表示该文件类型为:管道
'-'		表示该文件类型为:普通文件

# 字符串后九个字符中出现的参数及含义:
# 注:后九个字符其实就只包含了四个参数！
'r'		表示该文件允许读权限
'w'		表示该文件允许写权限
'x'		表示该文件允许执行权限
'-'		表示该文件不具备该位置上的对应权限

```

### 4.2连接数

```bash
-rw-rw-r-- 1 elsanfan elsanfan   1491 7月   7 14:26 database.cpp
# 信息含义 : 表示连接数
# 数字 1 表示连接数为 : 1
```

### 4.3 所有者

```bash
-rw-rw-r-- 1 elsanfan elsanfan   1491 7月   7 14:26 database.cpp
# 拥有者：elsanfan
```

### 4.4 所属用户组

```bash
-rw-rw-r-- 1 elsanfan elsanfan   1491 7月   7 14:26 database.cpp
# 所属组：elsanfan
```

### 4.5 文件大小

```bash
-rw-rw-r-- 1 elsanfan elsanfan   1491 7月   7 14:26 database.cpp
# 文件大小: 1491
```

### 4.6 最后修改时间

```bash
-rw-rw-r-- 1 elsanfan elsanfan   1491 7月   7 14:26 database.cpp
# 7月7日 14:26 修改
```

### 4.7 文件名

```bash
-rw-rw-r-- 1 elsanfan elsanfan   1491 7月   7 14:26 database.cpp
# 文件名: database.cpp
```



## 5、C 语言中static 和 const 关键字的作用

### 5.1 static

> - 修饰局部变量
>
>   > - 延长局部变量的生命周期（静态局部变量分配在 静态区（data/bss段））
>   > - 静态局部变量只初始化一次，默认值为0，值具有继承性，每次调用不重新赋值，使用上一次的值
>
> - 修饰函数/全局变量
>
>   > - 限定作用域范围：只在本文件中，不能再用 `extern` 关键字声明



### 5.2 const

> - 定义常量，使其不可变
>
> - 便于参数类型检查，消除隐患
>
> - 修饰变量
>
>   > - 修饰普通变量
>   > - 修饰指针变量
>
> - 节省空间，避免不必要的内存分配



# 02.数据结构

## 1、链表和顺序表的异同

| 链表                                   | 顺序表                                 |
| -------------------------------------- | -------------------------------------- |
| 链表采用链式存储结构，其内存空间不连续 | 顺序表采用顺序存储结构，内存空间是连续 |
| 动态分配内存空间，在堆区，需要手动释放 | 静态分配内存空间，在栈区，可以自动释放 |
| 动态分配空间，不定长度                 | 长度有限                               |
| 不能随机查找，只能依次访问，查询效率低 | 数据随机访问性比较强 ,查找速度块。     |



## 2、链式栈的封装形式及示意图

```c
struct node {
	int data;
	struct node *next;
};

struct linkstack {
	struct node *top;
};
```

![LinkStack](https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/LinkStack.webp)

## 3、双向链表的删除函数写法及注意事项

```c
bool delete_val(struct node *phead,int val)
{
	struct node *pdel = phead->next;
	
	while (pdel && pdel->data != val) {
		pdel = pdel->next;
	}
	if (pdel == NULL) {
		return false;
	}

	pdel->prev->next = pdel->next;
	if(pdel->next != NULL)         //删除最后一个元素要判断
	pdel->next->prev = pdel->prev;
	
	pdel->prev = NULL;
	pdel->next = NULL;
	free(pdel);

	return true;
}
```

## 4、二叉树遍历（前中后序）

前序、中序、后序

方法一：砍树法：从根节点开始劈砍，按前序、中序、后序摆放子树

方法二：

>  前序：根节点开始绕外围，从左到右环绕一圈
>
>  中序：把二叉树从上到下，拍扁
>
>  后序：从左到右，从下到上，像摘葡萄一样，取出值

代码实现：递归思想

```c
#include<stdio.h>
#include<stdbool.h>
#include<stdlib.h>
#include<string.h>

struct btree {
	int data;
	struct btree *left;
	struct btree *right;
};

void creat_btree(struct btree **t) 
{
	int val;
	scanf("%d",&val);
	if (val == -1) {
		t = NULL;
		return;
	} else {
		*t = (struct btree *)malloc(sizeof(struct btree));
		if ((*t) == NULL) {
			return;
		}
		(*t)->data = val;
		creat_btree(&((*t)->left));
		creat_btree(&((*t)->right));
	}
}

void print_pre_order(struct btree *bt) 
{
	if(bt == NULL) {
		return;
	} else {
		printf("%d ",bt->data);
		print_pre_order(bt->left);
		print_pre_order(bt->right);
	}
	 
}
void print_mid_order(struct btree *bt)
{
	if (bt == NULL) {
		return;
	} else {
		print_mid_order(bt->left);
		printf("%d ",bt->data);
		print_mid_order(bt->right);
	}
}

void print_bih_order(struct btree *bt)
{
	if (bt == NULL) {
		return;
	} else {
		print_bih_order(bt->left);
		print_bih_order(bt->right);
		printf("%d ",bt->data);
	}
}

int get_height(struct btree *bt)
{
	int l,r; //左右子树的高度
	if (bt == NULL) {
		return 0;	
	} else {
		l = get_height(bt->left);
		r = get_height(bt->right);
		return (l > r)?(l + 1):(r + 1);
	}
}

int main(int argc, const char *argv[])
{
	struct btree *tree;
	creat_btree(&tree);
	print_pre_order(tree);
	putchar('\n');
	print_mid_order(tree);
	putchar('\n');
	print_bih_order(tree);
	putchar('\n');

	printf("深度为：%d\n",get_height(tree));
	return 0;
}
```



## 5、举例说明队列的应用场景

队列的核心思想在于“先进先出”，凡是符合这一特点的场景，可以考虑用队列来处理。

比如：各类排队问题，日志处理，异步请求处理等。



# 03. Linux 下进程

## 1、Linux 系统下进程间通信方式

### 1.1 数据交换

数据交换要求2个进程间访问同一个资源，（内核空间或公有文件），与之相关的通信为：**管道、消息队列、共享内存**

### 1.2 信号通知

信号通知要求两个进程能相互通知对方，告知事件。使用 `kill()` 和 `signal()` 能够实现2个进程相互通知的效果，不过信号含义有限，且不能携带参数。

### 1.3 互斥同步

强调进程间运行关系，可以使用信号量集来实现，不过需要事先约定信号量集中信号量值的意义。

### 进程间通信方式比较 

- 传统的进程间通信分为：无名管道（pipe）、有名管道（fifo）、信号；

- System V 下进程间通信方式：消息队列、信号灯集、共享内存；

- 专门用于跨主机通信的BSD 套接字：socket

  

| 进程通信方式 | 特点                                                         | 备注                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 无名管道     | 1. 半双工<br />2. 只能用于亲缘间进程通信 <br />3. 只能一对一通信<br />4.  空管道造成读阻塞，管道满导致写阻塞 | 父子进程以文件IO形式访问同一段内核空间                       |
| 有名管道     | 1. 半双工<br />2. 任意间进程通信 <br />3. 只能一对一通信<br />4.  只有管道有读端存在，在管道中写数据才有意义。否则，写进程会收到内核发出的 `SIGPIPE` 信号 | 两个进程读写文件系统中的同一个文件                           |
| 信号         | 1. 只能通知某一进程发生了某一标准事件，不能携带数据信息<br />2. 异步通信方式，主要作用通知目标进程发生的标准事件 <br />3. 三种处理方式：默认处理、忽略信号、自定义信号处理函数<br />4.  信号源：异常、其他进程、终端的中断、作业的控制（前后台进程的管理）、分配额问题（cpu超时、文件过大等）、内核通知、报警 | 唯一的异步方式                                               |
| 消息队列     | 1. 一个消息链表，允许一个或多个进程向它写消息<br />2. 克服了信号传递信息少，管道只能支持无格式字节流和缓冲区受限的缺点 <br />3. 一个消息队列就可以实现多对多通信 | 多个进程访问内核管理的同一个队列<br />本质是Linux维护的一个消息队列向量表 |
| 共享内存     | 1.不需要任何函数即可操作数据<br />2.为了在多个进程间交换信息，内核专门留出一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间 | 效率最高的进程间通信方式                                     |
| 信号量集     | 1.内核管理的一堆计数器，标识了共享资源的访问资格数<br />2.由进程去操作指定集合中指定的信号量，只有成功占用了信号量才能访问共享资源 | 可以定制同步及互斥机制                                       |
| 套接字       | 1.主要用于不同主机间的进程通信<br />2.一个套接字接口可以看作是进程间通信的端点，每个套接字的名字是唯一的<br />3.套接字需要多种框架来维护，如：IO多路复用或者线程池<br />4.套接字依赖完备的通信协议 |                                                              |

- 管道：有名管道、无名管道
- 信号 （唯一的异步通信方式）
- 消息队列
- 共享内存 （效率最高）
- 信号灯集
- 套接字

## 2、系统调用和标准库分别是指？说明什么关系


**库函数**：是语言或应用程序的一部分，可以运行在用户空间中。

**系统调用**：是操作系统的一部分，是内核为用户提供的接口，运行在内核空间中。

联系：
许多库函数会使用系统调用来实现功能，没有使用系统调用的库函数，它的执行效率通常要比系统调用的高。

补充：
这里为什么会比系统调用的效率高？
因为系统调用时，需要进行上下文的切换及状态的转换（用户态和内核态）

## 3、线程和进程的异同

- 相同点：

  > - 线程和进程都是处理多任务的，使得一份代码能同时执行多个任务；
  > - 程序复杂性上升，任务之间如果有牵连还会涉及到同步与互斥相关技术；

- 不同点：

  > - 多进程占用系统资源较多，多线程占用系统资源较少；
  > - 每个进程拥有独立且完整的用户空间，每个线程自己只占用少量的栈空间，同时依赖所处进程的资源空间；
  > - 进程因为其独立性，所以进程间通信需要依赖一个公共的媒介（文件/内存），同进程下的多个线程公用进程资源，不存在通信这一说，但是要防止线程之间相互竞争资源（互斥/同步）；
  > - 多个进程间协同工作主要依赖通信及同步机制，多个线程间协同工作主要依赖互斥及同步机制（而且进程与线程同步互斥的控制方法完全不同）；

## 4、进程间同步互斥分别指什么

### 进程间同步：

并发性带来了异步性，有时候需要进程间相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序。

### 进程间互斥：

对临界资源的访问，需要互斥的进行。即，同一段时间内只能允许一个进程访问该资源。

## 5、父进程回收子进程资源的方式

###  1、`pid_t wait`

```c
pid_t wait(int *stat_loc);
```

回收僵尸态子进程，如果没有僵尸态子进程则阻塞，如果没有子进程立刻返回

###  2、`pid_t waitpid`

```c
 pid_t waitpid(pid_t pid, int *stat_loc, int options);
```

按照指定方式（是否阻塞）探测子进程状态改变，回收僵尸态子进程

# 04. Linux下线程

## 1、线程和进程的区别？各自的使用时机

### 1.1 进程

进程：计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。简言之运行的程序就是进程。

### 1.2 线程

线程：操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中实际运作单位。

### 使用场景

多进程和多线程都能“同时实现多个任务”。

假设任务A和B，都需要自己拥有独立的资源才能往下执行，那么必须是多进程。

假设任务A和B，都公用一套资源就能往下执行就首选多线程。

## 2、线程分离的方法及意义

### 线程分离

线程分离就是当线程被设置为分离状态后，线程结束时，它的资源会被系统自动的回收，而不再需要在其它线程中对其进行 pthread_join() 操作。

### 方法

```c
#include <pthread.h>

int pthread_detach(pthread_t tid);
//返回值：成功返回0，失败返回错误号。

//注意：线程分离可以在创建的时候属性里面设置
```

### 为什么要线程分离

在我们使用默认属性创建一个线程的时候，线程是 joinable 的。 joinable 状态的线程，必须在另一个线程中使用 pthread_join() 等待其结束，如果一个 joinable 的线程在结束后，没有使用 pthread_join() 进行操作，这个线程就会变成”僵尸线程”。每个僵尸线程都会消耗一些系统资源，当有太多的僵尸线程的时候，可能会导致创建线程失败。

## 3、线程互斥同步依赖的方法并举例应用场景

线程同步互斥依赖方法：**信号量、互斥锁、读写锁、条件变量**

简单模型：线程1占用了信号量1开始打印，线程2没能成功占用信号量2而阻塞；当线程1打印完释放信号量2时，线程2获得信号量2，线程2开始打印；如此循环往复实现两个线程同步打印。

## 4、写一个两个线程交替打印A、B的程序

```c
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <semaphore.h>

/* 两线程交替打印A、B  */
pthread_t tid[2];
sem_t printA_sem, printB_sem;

void *printA(void *arg)
{
	while (1) {
		sem_wait(&printA_sem);
		printf("Thread A print A\n");
		sleep(1);
		sem_post(&printB_sem);
	}
}

void *printB(void *arg)
{
	while (1) {
		sem_wait(&printB_sem);
		printf("Thread B print B\n");
		sleep(1);
		sem_post(&printA_sem);
	}
}

int main(int argc, const char *argv[])
{
	int ret;
	sem_init(&printA_sem,0,1);	
	sem_init(&printB_sem,0,0);
	
	ret = pthread_create(&tid[0],NULL,printA,NULL);
	if (ret != 0) {
		fprintf(stderr,"fail to create thread printA\n");
		return -1;
	}

	ret = pthread_create(&tid[1],NULL,printB,NULL);
	if (ret != 0) {
		fprintf(stderr,"fail to create thread printB\n");
		return -1;
	}

	pthread_detach(tid[0]);
	pthread_detach(tid[1]);
	
	while (1) ;

	return 0;
}
```



# 05.网络

## 1、IPV4和IPV6的区别？

- IPV4 --- Internet Protocol Version 4
- IPV6 --- Internet Protocol Version 6

都属于ip协议，IPV6是用于替换IPV4的下一代ip协议

### 相对于 ipv4 ,ipv6 具有如下特点

1. 更大的地址空间

2. IPv6 的地址长度为 128 位，是 IPv4 地址长度的 4 倍。于是 IPv4 点分十进制格式不再适用，采用十六进制表示

3. 更小的路由表

4. IPv6 的地址分配一开始就遵循聚类(Aggregation)的原则，这使得路由器能在路由表中用一条记录(Entry)表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度
5. 增强的组播支持以及对流的支持
6. 这使得网络上的多媒体应用有了长足发展的机会，为服务质量(QoS)控制提供了良好的网络平台
7. 加入了对自动配置的支持
8. 这是对 DHCP 协议的改进和扩展，使得网络(尤其是局域网)的管理更加方便和快捷
9. 更高的安全性
10. 在使用 IPv6 网络中用户可以对网络层的数据进行加密并对 IP 报文进行校验,这极大的增强了网络安全

## 2、简述TCP的链接过程

### 三次握手

> SYN ---- 请求连接 ACK ---- 表示应答  FIN ---- 请求断开
>
> - Server <----- 	Client          SYN = 1
> - Server ----->     Client         SYN = 1 ACK = 1
> - Server <-----     Client         ACK = 1

## 3、局域网内聊天室的项目框架？

整个项目分为客户端与服务器，通过局域网群发及私发通讯。项目涉及的框架及数据结构如下图所示:

**客户端：**主要功能是向局域网内服务器发送协议数据，以实现登录、注册、群发、私发等功能；其特点在于和用户的交互，并采用 2 个线程协同：主线程负责与用户交互，等待用户选择功能；而子线程负责监听套接字数据，并在适当的时机打印，以实现群聊效果；

**服务器：**为多个客户端服务，建立起类似于组播/单播的机制，具体实现细节如下：

1. 网络通讯模块是基于 Linux socket 接口实现，使用 udp 协议/TCP 协议均可。但 udp 协议非面向连接的协议，传输速度快，缺点是客户端是否在线是否收到数据，服务端并不知道。我们这里没有设计心跳包及应答机制，暂且忽略。（使用 TCP 则没有这个问题） 

2. 服务器上有一个链表，其功能是保存客户端的地址信息，包括客户端的 ip 地址与端口号。为服务器遍历活跃客户端提供了可能，同时客户端的注册、登录、退出、群发都需要依赖服务器上的链表数据；第 50 页 

3. 为提高服务器性能，采用了多线程并发方案，配合读写锁互斥，使得多个线程都能单独完成服务器中的注册、登录、退出、群发、私发。同时接收多客户端数据时利用套接字本身的缓冲属性存储客户端请求数据，然后由主线程获取单个单个的数据包，启动相应的线程完成相应的功能。

## 4、网络电子词典是如何实现的？

网络电子词典项目是一款基于网络的以单词查询为主要功能的软件,具体实现功能如下:

1. 单词查询,账号注册与登录,历史记录管理,客户端掉线检测

2. 整个项目是基于 C/S 架构，分为客户端与服务器,具有如下特点:

   > - 支持高并发,使用多进程的方案
   >
   > - 高可靠性，在应用层基于自定义协议,在底层基于 tcp 协议

3.  项目主要分为如下模块:

   > - 网络通讯模块,传输层基于 tcp 协议,应用层基于自定义协议
   >
   > - 数据持久化模块,使用轻量级数据库 SQLITE3
   >
   > - 客户端菜单模块,使用命令行界面

4. 网络模块采用 tcp 协议与自定义协议，以保证数据通讯可靠性,支持客户端掉线检测

5. 数据持久化模块使用了 SQLITE3 数据库,数据内容由 user 表与 dict 表来管理

   > - user 表，用于管理用户账号信息；
   > - dict 表，用于管理单词信息

6. 客户端菜单模块，基于命令行界面，使用了二级模式,在登录成功后，可以进行相应的单词查询

## 5、sqlite3数据库的常用增删改查指令格式

1. 插入记录: 

   ```sqlite
   insert into <tablename>(column1,column2,...) values(value1,value2,...);
   ```

2. 删除记录: 

   ```sqlite
   delete from <tablename> where <condition> 
   ```

3. 查询记录：

   ```sqlite
   select <column1,column2,...> from <tablename> where <condition>
   ```

4. 修改记录：

   ```sqlite
   4. update set column1 = value1,column2 = value2,...,columnN = valueN where condition;
   ```

## 6、简述IO多路复用的方式及原理

io 多路复用实现了单个进程处理多路 I/O 请求，相比使用多进程与多线程更加节约资源。在 Linux 

系统中共有三种多路复用方案，分别为:select、poll、epoll，它们的特点如下：

|        | 原理（特点）                                                 | 优缺点                                                       |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| select | 1. 将文件描述符添加到描述符集合 setfd（按二进制操作的数组）中；<br />2.通过系统调用 select()将 3 个描述符集合拷贝到内核中，当前进程阻塞；<br />3.如果有文件描述符就绪，内核就返回集合到应用层，供用户遍历处理 | 1. 文件描述符集合长度有限，一般为1024个；<br />2.文件描述符不连续的情况会降低遍历集合的效率<br />3.每一轮检测需要备份和重置文件描述符集合，这样有损效率 |
| poll   | 1.用结构体 pollfd 描述 IO 事件，用结构体数组表示事件集合<br />2.在内核中对所有的文件描述符进行遍历，检测是否有 IO 事件发生；<br />3.当有 IO 事件发生时，则返回结构体数组到应用层，用户遍历即可获知检测结果 | 1.事件结构体数组突破了大小限制，但太长会降低内核检测效率<br />2.每一轮检测不再需要备份和还原文件集合的信息 |
| epoll  | 1.使用红黑树来管理文件描述符事件结构；<br />2.采用基于事件的就绪通知方式，一旦基于某个文件发生 IO 事件时，函数poll_wait()便会返回描述事件的结构体数组；<br />3.用户遍历描述 IO 事件的结构体数组确定具体的 IO 事件； | 1.没有最大限制，并且可以动态增加与删除文件描述符；<br />2.不需要备份和还原记录文件描述符集合的数据结构；<br />3.支持边沿触发模式，IO 事件若不处理，在 ET 模式下不再重复通知用户，直到下一次IO 事件再发起通知。而不是像 poll 和select 机制那样，一直通知用户。 |



# 06.通信接口及中断

## 1、IIC 和 SPI的时序

### IIC

有3种类型信号：**开始信号、结束信号、响应信号**

> 1. 开始信号(S):SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据 
> 2. 结束信号(P):SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据 
> 3. 响应信号(ACK):接收器在接收到8位数据后，在第9个时钟周期，拉低 SDA 电平 

<img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/IIC_Bus.png" alt="IIC signal" style="zoom: 67%;" />

***Read Sequence*** 

> <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/IIC_ReadSequence.png" style="zoom:80%;" />

***Write Sequence***

> <img src="https://cdn.jsdelivr.net/gh/Zoom-EobardThawne/MyPicGo/img/IIC_WriteSequence.png" style="zoom:80%;" />



### SPI

SPI 主要使用4个信号:

主机输输出/从机输入(MOSI: Master Output Save Input) 、 

主 机 输 入 / 从 机 输 出 (MISO:Master Input Save Output)、

串行时钟(SCLK 或 SCK)

外设片选(CS)



## 2、什么是同步，什么是异步通信

- 同步

  > 同步通信是一种连续串行传送数据的[通信方式](https://so.csdn.net/so/search?q=通信方式&spm=1001.2101.3001.7020)，一次通信只传送一帧信息。这里的信息帧与异步通信中的字符帧不同，通常含有若干个数据字符。

- 异步

  > 异步通信是一种很常用的通信方式。异步通信在发送字符时，所发送的字符之间的时间间隔可以是任意的。当然，接收端必须时刻做好接收的准备。发送端可以在任意时刻开始发送字符，因此必须在每一个字符的开始和结束的地方加上标志，即加上开始位和停止位，以便使接收端能够正确地将每一个字符接收下来。异步通信的好处是通信设备简单、便宜，但传输效率较低（因为开始位和停止位的开销所占比例较大）。

## 3、volatile有什么作用

volatile修饰一个变量，**防止编译器优化（本质）**，告诉编译器每次使用该变量时，必须从变量所在的内存重新读值

- 有中断处理函数的代码，使用了全局变量，需要注意什么问题？

  > 定义全局变量的时候，**需要加volatile修饰**

## 4、简述中断的上下部

### 中断上半部

中断处理函数（屏蔽外部中断），上半部执行紧急的、耗时短的任务

### 中断下半部

不屏蔽外部中断，分为软中断、tasklet、工作队列（workqueue）

| 软中断           | tasklet          | 工作队列         |
| ---------------- | ---------------- | ---------------- |
| 复杂度高，性能好 | 复杂度中，性能中 | 复杂度低，性能差 |
| 中断上下文       | 中断上下文       | 进程上下文       |
| 不可休眠         | 不可休眠         | 可休眠           |



# 07.C++基本特性

## 1、C++ 比较 C语言多了哪些特性？

> - C语言：程序化开发语言，面向过程思想，适用于小规模问题的程序
> - C++：面向对象的编程思想，适用于大规模问题的合作开发

C++的加强部分：

> - 命名空间
> - 重载：函数重载、运算符重载
> - 引用
> - 面向对象：封装、继承、多态
> - 泛型编程
> - 异常处理
> - 标准库STL

## 2、简述虚析构函数的由来

建议将基类的析构函数设置为是虚函数，基类的析构函数声明为虚函数，则派生类的析构函数自动为虚函数

**当基类的指针指向派生类对象时，如果析构函数不是虚函数，则不会发生动态多态，而导致只会调用基类的析构函数，造成内存泄漏**

## 3、什么是友元？什么是引用？

### 3.1友元（友元类/友元类）

- 友元函数不是类的成员函数，在类中声明，在类外定义

- 友元函数可以访问所有私有成员和保护成员，一般不会使用，这样会破坏面向对象的封装性

- 注意：

  > - 友元不具有相互性 --- A是B的友元，不代表B是A的友元
  > - 友元不能被继承 --- 父类的友元不一定是子类的友元
  > - 友元不具备传递性 --- 你的朋友的朋友不一定是你的朋友

### 3.2引用

#### 引用原理、作用和使用规则

- 原理：引用的本质是，指针常量的使用：`int *const p`

- 作用：

  > - 简化指针操作
  > - 引用给一个变量起了一个别名，对引用操作与对其绑定的变量或对象，操作一样

- 规则：

  >- `<类型> &<引用名> = <目标变量或对象名>` ---- `int & a = b`
  >- 引用声明必须初始化，初始化后不能改变引用空间的位置 ---- **必须绑定只能绑定一次**
  >- 引用的类型和目标变量或对象**类型必须一致**
  >- 不能把已经有的引用名作为其他变量或对象的名字或别名
  >- *使用引用时，编译器底层生成指针，对其自动 \* 运算*



#### 引用的用法

- 函数传参 （主要）

  ```c++
  void swap(int &a, int &b) //交换两个数
  {
      int tmp = a;
      a = b;
      b = tmp;
  }
  ```

- 函数返回值 （返回变量须静态，函数可做左值）

  ```c++
  int &retFunc(int a)
  {
      static b = a + 1;
      return b;
  }
  int main()
  {
      int a = 1;
      int &p = retFunc(a);
      cout << p << endl;
      retFunc(a) = 80;
      cout << p << endl;
      return 0;
  }
  ```

- 对数组引用

  ```c++
  int a[5] = {0};
  int (&p)[5] = a;
  
  int (&func())[5]
  {
      static int a[5] = {1,2,3,4,5};
      return a;
  }
  ```

- 对指针引用 (几乎不用)

  ```c++
  int a = 10;
  int *p = &a;
  int *&q = p;
  ```

  

##  4、简述封装、继承、多态

- 封装

> "把一个或多个项目封闭在一个物理的或者逻辑的包中"。在面向对象程序设计方法论中，**封装是为了防止对实现细节的访问**。封装**只公开某些对外接口，隐藏具体实现细节。增加了一定的安全性，防止信息的泄露以及破坏。**

- 继承

> **继承是代码复用的一种形式。使用继承可以复用现有类的数据和行为，为其赋予新功能而创建出新类。** 在现有类（基类、父类）上建立新类（派生类、子类）的处理过程称为继承。派生类能自动获得基类的除了构造函数和析构函数以外的所有成员，可以在派生类中添加新的属性和方法扩展其功能

- 多态

> **多态指在程序设计中存在同名不同方法的存在，主要通过子类对父类的覆盖来实现多态，设计原则之一就是要依赖于抽象，而不依赖于具体，增加灵活性。多态就是为了体现这一原则。**

## 5、简述重载、重写（覆盖）、隐藏，以及他们的区别

- 重写：派生类重新实现基类的虚函数

  > 不同作用域
  >
  > 函数名相同、参数相同、返回值相同
  >
  > 基类必须有虚函数
  >
  > 重写函数的权限限定符可以不同

- 函数重载：同一个作用域参数不同的同名函数

  > 同一个作用域
  >
  > 函数名相同、参数不同、返回值可同可不同
  >
  > 可以不是虚函数

- 隐藏：基类和派生类同名函数，总是调用子类的函数，隐藏父类函数

  > 不同作用域
  >
  > 函数名相同
  >
  > **参数不同**，**无论有没有virtual**关键字，基类函数都将隐藏
  >
  > **参数相同**，但基类**没有virtual**关键字，基类函数将被隐藏



# 08.C++标准模板库

- 六大组件：**容器(Container)、迭代器(Iterator)、算法(Algorithm)、**仿函数(Functor)、适配器(Adaptor)、分配器(Allocator)

## 容器

- 容纳、包含一组元素或元素集合

### 序列式容器

**向量 --- vector**：本质是动态数组，尾端增删性能高

列表 --- list：本质是双向循环链表，任何位置增删性能好，随机访问慢

双端队列 --- deque：本质是动态数组，随机存取好，仅次于vector

### 关联式容器

- 查找数据性能好

集合(set)与多重集合(mulitiset)：set不允许重复，mulitiset允许数据重复

**映射(map)与多重映射(mulitimap):**

> - 键值对容器，数据成对出现，第一个值为key，第二个字为value，key只能在map出现一次，mulitimap允许key重复

## 迭代器

- 检查容器内元素并遍历元素的数据类型
- C++趋向用迭代器而不是下标
