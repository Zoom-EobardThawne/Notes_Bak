# 顺序表





# 单链表

单链表---基于指针实现，课程中定义一个结构体node，作为链表中的节点，每个节点分有：数据域和指针域

## 基本运算操作 --- 增删查改

### 尾插法 --- insert_val_tail

- 堆区申请一个新的节点空间
- 判断是否申请成功后，给新节点初始化
- 定义一个活动指针 （pcur），让pcur指向链表最后一个节点 （通过循环实现）
- 此时pcur指向最后一个节点位置，让pcur的指针域指向新节点
- 尾插完成

### 按值插入--- insert_val_after

- 堆区申请一个新的节点空间
- 判断是否申请成功后，给新节点初始化
- 定义一个活动指针 （pcur），利用pcur 寻找到匹配的值的节点位置
- 如果没找到匹配的值，退出函数 ；找到了匹配的值，对相邻节点进行链接
- 按值插入完成

### 删除单个匹配值的节点--- delete_val

- 定义两个指针，分别指向头节点和头节点后一节点
- 两个指针同时后移，快指针匹配到值后，把当前节点的后一节点和当前节点的前一节点相连
- 如果没有匹配到值，直接退出
- 把删除的节点数据域和指针域，分别置零和置空 <!--注意避免野指针-->
- 释放删除的节点的内存空间 <!--释放内存-->

### 打印单链表--- print_linklist

- 定义一个活动指针（pcur）
- 从头节点的后一个节点开始，遍历整个链表 <!--注意：pcur != NULL; 才是完整遍历的约束条件-->
- 每指向一个节点就打印输出其数据域的值

## 单链表逆序

- 定义前中后，三个指针，前后移动 （pbefore、pcur、pafter）
- pbefore指向头节点 pcur 指向头节点后一节点
- 判断一下，是否链表只有一个头节点
- 循环依次移动三个指针，pafter指向pcur后面一个节点  ，直到pcur为NULL时，结束
- 每循环一次，都让pcur指向的当前节点，指向前一个节点
- 循环结束时，pbefore指向尾节点
- 将指向头节点的节点指针域置空
- 将头节点指向pbefore



# 双链表

## 基本运算---增删查改
### 尾插法 --- insert_val_tail

步骤同单链表

### 按值插入--- insert_val_after

步骤同单链表
### 删除单个匹配值的节点--- delete_val
步骤同单链表 
<!--注意：不用定义两个指针了，双链表保存了前一节点的地址。此外，双链表删除最后一个元素时，记得判断处理，不要访问后继节点了，防止段错误-->

### 打印单链表--- print_linklist
步骤同单链表

<!--双链表本身就支持正反两个方向访问，就不需要专门写逆序操作了-->



# 循环链表

## 基本运算---增删查改
### 尾插法 --- insert_val_tail
步骤基本同单链表
### 按值插入--- insert_val_after
步骤基本同单链表
### 删除单个匹配值的节点--- delete_val
步骤基本同单链表 
### 打印单链表--- print_linklist
步骤基本同单链表



<!--注意：循环链表节点初始化，指针域指向节点自身，遍历时从phead->next,开始，再次指向phead结束-->

# 栈

> **栈**----**先进后出** 数据的出入口在一个位置
>
> > 栈中主要包括，存储的数据，和一个**指向栈顶的变量（`top`）**
> >
> > 基本运算：入栈、出栈、栈判空、栈判满、获取栈顶元素



## **顺序栈**

> >- 基于数组实现，指定了最大长度 (`MAXSIZE`)
>>
> >- 通过`top`进行初始化、判空、判满的操作，`top`对应数组元素的下标
> >
> >- 出栈：先判空，若不为空，`top`下移
> >
> >- 获取栈顶元素：通过top所在的位置就是栈顶，通过top访问



## **链栈**

> 链式存储结构，基于指针
>
> - 定义节点结构体
>
> >```c
>>struct node {
> >	int data;
> >	struct node *next;
> >};
> >```
> 
> - 定义链栈结构体，里面为指向栈顶的节点的指针
>
> >```c
>>struct linkstack {
> >	struct node *top;
> >};
> >```
> >
> 
> - 初始化
>
> >把`top`指向NULL
>- 入栈：开辟内存存放新节点，链接节点，top上移
> - 出栈：释放节点内存，指针域置空，top下移
> 
> > 基本操作参考链表的使用





# 队列

## **顺序队列**

> > - 基于数组实现，有指定最大值
> >
> > - 结构体构成 --- 数组、队头、队尾
> >
> >   ```c
> >   struct queue {
> >       int data[MAXSIZE];
> >       int front;
> >       int rear;
> >   };
> >   ```
> >
> > - 初始化：
> >
> >   > `memset();`函数把数组置零，让队头和队尾，都等于0
> >
> > - 入队：
> >
> >   > 判满：`if(q->rear == MAXSIZE)`
> >   >
> >   > 插入的值，放到rear下标位置，rear后移
> >
> > - 出队
> >
> >   > 判空：`if (q->front == q->rear) ` 首尾位置相等，没有元素可出队
> >   >
> >   > 通过指针传递，出队的元素值
> >   >
> >   > 队头指针后移一位
>





## **链队列**

> > - 基于指针实现，除非物理内存不足，没有存储上限
> >
> > - 结构体构成 --- 头节点、队头节点指针、队尾节点指针 <!--首先要构造一个节点类型的结构体-->
> >
> >   ```c
> >   struct linkqueue {
> >       struct node head; //头节点
> >       struct node *front; //队头节点指针
> >       struct node *rear; //队尾节点指针
> >   };
> >   ```
> >
> > - 初始化：
> >
> >   > 头节点`head` 数据域置零`head.data = 0;` 指针域置空 `head.next = NULL;` 
> >   >
> >   > 队头和队尾节点指针，全部指向头节点
> >   >
> >   > `lq->front = &lq->head`  `lq->rear = &lq->head` 
> >   >
> >   > <!--lq表示，链队列类型的指针-->
> >
> > - 入队：
> >
> >   > 堆区开辟一个新节点的内存空间，并判断是否开辟成功
> >   >
> >   > 新节点初始化
> >   >
> >   > 队尾节点的指针域，指向新节点 ，和新节点链接`lq->rear->next = pnew;`
> >   >
> >   > 队尾指针指向新节点地址
> >
> > - 出队
> >
> >   > 基本思想：队头指针始终指向头节点，固定不动。通过将头节点的指针域，指向出队节点的后一个节点，实现出队
> >   >
> >   > 头指针不需要出队
> >   >
> >   > 注意：在**最后一个元素即将出队**时，要将**队尾节点**指向**头节点**，以此来还原原始的队列状态
> >   >
> >   > <!--队头和队尾，相等，队列为空-->
> >   >
> >   > ```c
> >   > if (lq->front == lq->rear) //返回false，队列为空，退出函数
> >   >     
> >   > if (lq->front->next == lq->rear) //说明头节点的后一个节点，就是最后一个节点了
> >   >     lq->rear = lq->front;        //让队头和队尾都指向head





## **循环队列**

> > - 基于数组实现，有指定最大值
> >
> > - 结构体构成 --- 数组、队头、队尾
> >
> >   ```c
> >   struct circle_queue {
> >       int data[MAXSIZE];
> >       int front;
> >       int rear;
> >   };
> >   ```
> >
> > - 初始化：
> >
> >   > `memset();`函数把数组区域置零，让队头和队尾，都等于0
> >
> > - 循环的实现思想：
> >
> >   > 利用了对同一个数字， 取余数的结果，是从零开始循环的特性
> >   >
> >   > `rear % MAXSIZE` 的结果从0~MAXSIZE-1循环，刚好符合了数组的下标特点
> >
> > - 判满
> >
> >   > `if ((cq->rear + 1) % MAXSIZE == cq->front) ` 
> >   >
> >   > 牺牲一个元素位置，让队首和队尾之间只剩一个空位的时候，就判断为满。
> >   >
> >   > 如此一来，将满状态 和 空状态，区分开
> >
> > - 判空
> >
> >   > `if (cq->front == cq->rear)` 
> >   >
> >   > 首尾相等为空
> >
> > - 入队：
> >
> >   > 先判满
> >   >
> >   > 不为满时，队尾存入数据
> >   >
> >   > 队尾 `rear` 等于 自身加1 再对MAXSIZE取余
> >   >
> >   > `cp->rear = (cq->rear + 1) % MAXSIZE`
> >
> > - 出队：
> >
> >   > 先判空
> >   >
> >   > 不为空时
> >   >
> >   > 队头 `front` 等于 自身加1 再对MAXSIZE取余
> >   >
> >   > `cp->front = (cq->front + 1) % MAXSIZE`
> >



# 哈希表

## hash函数

将要存储的数据，通过hash函数，转化为一个key值。这个key就代表，数据在hash表中的位置。

课堂采用的hash函数是取余法

`f(key) = val % MAXSIZE; //MAXSIZE是哈希表的最大长度`

## hash 冲突

当我们存储的数据较多，或者hash表比较小时，就会出现不同数据的key值相同的情况，这时就产生了hash冲突

解决hash冲突有两种方法：

> **开放地址法：**
>
> > 当key重复的时候，重复的val的key值后加一个增量，再对MAXSIZE取余，产生新的key值，向hash表后寻找空位置，即：
> >
> > `f(key) = ( f(key) + d) % MAXSIZE`
> >
> > 课堂采用的是线性探查，d取（1、2、3...m-1），每次增加1
>
> **链接地址法：**
>
> > 采用节点储存数据，建立哈希表，产生hash冲突时，key相同的val在同一个链路建立链接，同一链路中有重复值就不存储
> >
> > hash表的MAXSIZE就代表最多的链路数
> >
> > 同一链路的节点链接时，采用头插法

# 树

## 树的基本概念

> 一个**节点的子树的个数**称为该**节点的度数**，一棵**树的度数**是指该**树中节点的最大度数**。

> **度数为零**的节点称为**树叶或终端节点**，度数不为零的节点称为分支节点，除根节点外的 分支节点称为内部节点。

> 一个节点的子树之根节点称为该节点的子节点，该节点称为它们的父节点，同一节点的各个子节点之间称为兄弟节点。一棵树的根节点没有父节点，叶节点没有子节点。

> **层数**：节点的层数等于父节点的层数加一，**根节点**的**层数定义为一**。树中节点层数的最大值称为该树的**高度或深度**。

> **树的逻辑结构** ：树中**任何节点**都可以有**零个或多个直接后继节点**（子节点），但**至多只有一个直接前趋节点**（父节点），根节点没有前趋节点，叶节点没有后继节点。 

## 二叉树

定义：是n（n≥0）个节点的有限集合，它或者是空集（n＝0），或者是**由一个根节点**以及**两棵互不相交的、分别称为左子树和右子树**的二叉树组成。

二叉树严格区分左孩子和右孩子，即使**只有一个子节点也要区分左右**。

 ### 二叉树的性质

- 二叉树第i（i≥1）层上的节点最多为2^i-1^个。

- 深度为k（k≥1）的二叉树最多有2^k^－1个节点。

- 在任意一棵二叉树中：树叶的数目比度数为2的节点的数目多一。

  - 总节点数为各类节点之和：n = n~0~ + n~1~ + n~2~ 

  - 总节点数为所有子节点数加一：n = n~1~ + 2*n~2~ + 1
    		故得：n~0~ = n~2~ + 1 ;

- 满二叉树 ：深度为k（k≥1）时有2^k^－1个节点的二叉树。

- 完全二叉树 ：只有最下面两层有度数小于2的节点，且最下面一层的叶节点集中在最左边的若干位置上。

- 具有n个节点的完全二叉树的深度为
  		 log~2~(n+1) <= h <=log~2~n+1

### 二叉树排序

前序、中序、后序

方法一：砍树法：从根节点开始劈砍，按前序、中序、后序摆放子树

方法二：

>  前序：根节点开始绕外围，从左到右环绕一圈
>
> 中序：把二叉树从上到下，拍扁
>
> 后序：从左到右，从下到上，像摘葡萄一样，取出值

### 二叉树还原

至少知道一个二叉树的前序和中序  或者  后序和中序

### 二叉树遍历

[二叉树排序和遍历算法](https://blog.csdn.net/chinesekobe/article/details/110874773?spm=1001.2014.3001.5506)

# 哈夫曼编码

**编码思想**

> - 根据字符出现的概率大小进行编码,出现概率高的字符使用较短的编码,出现概率低的使用较长的编码 
>
> - Huffman 编码是基于二叉树实现,构建的树叫做 **Huffman 树** 
>
> - Huffman 树的每个叶子结点的值则对应每个字符的权值 

**哈夫曼树创建**

> - 假设 A,B,C,D,E 五个字符,出现的频率(**权值**) 分别为 5 4 3 2 1，具体的构建步骤如下: 
>
> - step 1 : 先取两个最小权值作为左右子树构造一个新树 
>
> - step 2 : 将前一个颗树的根节点放在剩下的集合中,{5,4,3,3} 
>
> - step 3 : 重复第一步取两个最小权值构成新树，依次构建 huffman 树

**哈夫曼路径**

> - huffman 路径是指从根节点到叶子节点的访问路线 
>
> - huffman 路径长度是指路径上分支的数目 
>
> - huffman 权值表示出现的频率 
>
> - huffman 带权路径长度的计算公式如下: 

```c
	WPL = 权值1 * 路径长度1 + 权值2 * 路径长度2 +.....
```

# 上述数据结构运算操作总结

| 数据结构类型 | 插入 | 删除 | 查找 | 判断 |
| ------------ | ---- | ---- | ---- | ---- |
| 顺序表       |      |      |      |      |
| 链表         |      |      |      |      |
| 栈           |      |      |      |      |
| 队列         |      |      |      |      |
| 哈希表       |      | x    |      |      |
| 二叉树       |      |      |      |      |



# 排序算法



##  快排

## 堆排
